import cv2
import torch
import os
import time
from datetime import datetime, timezone, timedelta
import RPi.GPIO as GPIO
from mfrc522 import SimpleMFRC522
import requests
import sqlite3
import threading # Make sure threading is imported
from dotenv import load_dotenv

# --- T·∫¢I BI·∫æN M√îI TR∆Ø·ªúNG T·ª™ FILE .ENV ---
load_dotenv()

# --- L·∫§Y C√ÅC BI·∫æN C·∫§U H√åNH T·ª™ M√îI TR∆Ø·ªúNG ---
API_ENDPOINT = os.getenv("API_ENDPOINT", "http://localhost:3000/parking/add")
DB_FILE = os.getenv("DB_FILE", "parking_data.db")
IMAGE_DIR = os.getenv("IMAGE_DIR", "offline_images")
YOLOV5_REPO_PATH = os.getenv("YOLOV5_REPO_PATH")
LP_DETECTOR_MODEL_PATH = os.getenv("LP_DETECTOR_MODEL_PATH")
LP_OCR_MODEL_PATH = os.getenv("LP_OCR_MODEL_PATH")

# Ki·ªÉm tra c√°c bi·∫øn quan tr·ªçng
if not all([API_ENDPOINT, DB_FILE, IMAGE_DIR, YOLOV5_REPO_PATH, LP_DETECTOR_MODEL_PATH, LP_OCR_MODEL_PATH]):
    print("‚ùå L·ªói: M·ªôt ho·∫∑c nhi·ªÅu bi·∫øn m√¥i tr∆∞·ªùng quan tr·ªçng ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p trong file .env.")
    print("Vui l√≤ng ki·ªÉm tra c√°c bi·∫øn: API_ENDPOINT, DB_FILE, IMAGE_DIR, YOLOV5_REPO_PATH, LP_DETECTOR_MODEL_PATH, LP_OCR_MODEL_PATH")
    exit()

# --- MODULES C·ª¶A B·∫†N (ƒê·∫£m b·∫£o ch√∫ng t·ªìn t·∫°i v√† ƒë√∫ng ƒë∆∞·ªùng d·∫´n) ---
# Gi·∫£ s·ª≠ ch√∫ng ƒë∆∞·ª£c ƒë·∫∑t trong th∆∞ m·ª•c 'function' c√πng c·∫•p v·ªõi file script n√†y
try:
    import function.utils_rotate as utils_rotate
    import function.helper as helper
    print("‚úÖ T·∫£i module utils_rotate v√† helper th√†nh c√¥ng.")
except ImportError:
    print("‚ùå L·ªói: Kh√¥ng th·ªÉ t·∫£i module utils_rotate ho·∫∑c helper. Vui l√≤ng ki·ªÉm tra ƒë∆∞·ªùng d·∫´n v√† s·ª± t·ªìn t·∫°i c·ªßa file.")
    # ƒê·ªãnh nghƒ©a h√†m mock n·∫øu kh√¥ng c√≥ module ƒë·ªÉ code v·∫´n ch·∫°y ƒë∆∞·ª£c ph·∫ßn n√†o
    class MockHelper:
        @staticmethod
        def read_plate(model, image):
            print("‚ö†Ô∏è S·ª≠ d·ª•ng MockHelper.read_plate")
            if time.time() % 10 > 3: return f"MOCK{int(time.time())%1000:03d}LP"
            return "unknown"
    class MockUtilsRotate:
        @staticmethod
        def deskew(image, cc, ct):
            print("‚ö†Ô∏è S·ª≠ d·ª•ng MockUtilsRotate.deskew")
            return image
    helper = MockHelper()
    utils_rotate = MockUtilsRotate()


# --- C√ÅC H√ÄM TI·ªÜN √çCH ---
def get_vietnam_time_str():
    """L·∫•y th·ªùi gian hi·ªán t·∫°i ·ªü Vi·ªát Nam, ƒë·ªãnh d·∫°ng YYYY-MM-DD HH:MM:SS"""
    vietnam_tz = timezone(timedelta(hours=7))
    return datetime.now(vietnam_tz).strftime("%Y-%m-%d %H:%M:%S")

def sanitize_filename_component(name_part):
    """L√†m s·∫°ch m·ªôt ph·∫ßn c·ªßa t√™n file."""
    return "".join(c if c.isalnum() else "_" for c in str(name_part)).rstrip("_")

# --- C√ÅC H√ÄM LI√äN QUAN ƒê·∫æN DATABASE V√Ä SERVER ---
def init_db():
    """Kh·ªüi t·∫°o c∆° s·ªü d·ªØ li·ªáu v√† b·∫£ng n·∫øu ch∆∞a t·ªìn t·∫°i."""
    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS transactions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                plate TEXT NOT NULL,
                token TEXT NOT NULL,
                timestamp TEXT NOT NULL,
                image_path TEXT NOT NULL,
                synced INTEGER NOT NULL DEFAULT 0
            )
        ''')
        conn.commit()
    print(f"‚úÖ ƒê√£ kh·ªüi t·∫°o ho·∫∑c k·∫øt n·ªëi t·ªõi CSDL: {DB_FILE}")
    os.makedirs(IMAGE_DIR, exist_ok=True)

def send_data_to_server(plate_text, token_id, timestamp_str, image_data_bytes) -> bool:
    """
    G·ª≠i d·ªØ li·ªáu (bao g·ªìm ·∫£nh) l√™n server.
    Tr·∫£ v·ªÅ True n·∫øu th√†nh c√¥ng, False n·∫øu th·∫•t b·∫°i.
    """
    print(f"üì° ƒêang th·ª≠ g·ª≠i d·ªØ li·ªáu t·ªõi server: {API_ENDPOINT} cho bi·ªÉn s·ªë {plate_text}")
    payload = {
        'plate': plate_text,
        'token': str(token_id),
        'time': timestamp_str
    }
    files_payload = {
        'image': ('image.jpg', image_data_bytes, 'image/jpeg')
    }
    try:
        response = requests.post(API_ENDPOINT, data=payload, files=files_payload, timeout=5) # Ng·∫Øn h∆°n cho g·ª≠i tr·ª±c ti·∫øp
        if response.status_code == 200:
            print("‚úÖ G·ª≠i d·ªØ li·ªáu l√™n server th√†nh c√¥ng!")
            try:
                print("   => Ph·∫£n h·ªìi t·ª´ server:", response.json())
            except requests.exceptions.JSONDecodeError:
                print("   => Ph·∫£n h·ªìi t·ª´ server (kh√¥ng ph·∫£i JSON):", response.text)
            return True
        else:
            print(f"‚ùå Server tr·∫£ v·ªÅ l·ªói! M√£: {response.status_code} - {response.text}")
            return False
    except requests.exceptions.Timeout:
        print("‚ùå Timeout khi g·ª≠i d·ªØ li·ªáu.")
        return False
    except requests.exceptions.ConnectionError:
        print("‚ùå L·ªói k·∫øt n·ªëi m·∫°ng khi g·ª≠i d·ªØ li·ªáu.")
        return False
    except requests.exceptions.RequestException as e_req:
        print(f"‚ùå L·ªói Request kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i d·ªØ li·ªáu: {e_req}")
        return False
    except Exception as e_send: # B·∫Øt c√°c l·ªói kh√°c c√≥ th·ªÉ x·∫£y ra
        print(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh trong qu√° tr√¨nh g·ª≠i d·ªØ li·ªáu: {e_send}")
        return False

def save_record_to_local_db(plate, token_id, image_frame_to_save, timestamp_to_save, reason=""):
    """L∆∞u b·∫£n ghi v√†o CSDL c·ª•c b·ªô khi g·ª≠i tr·ª±c ti·∫øp th·∫•t b·∫°i."""
    print(f"üíΩ ƒêang l∆∞u v√†o CSDL c·ª•c b·ªô. L√Ω do: {reason}")
    plate_fn_safe = sanitize_filename_component(plate)
    time_fn_safe = sanitize_filename_component(datetime.now().strftime("%Y%m%d_%H%M%S_%f"))
    image_filename = f"{time_fn_safe}_{plate_fn_safe}.jpg"
    image_path_tosave = os.path.join(IMAGE_DIR, image_filename)
    try:
        cv2.imwrite(image_path_tosave, image_frame_to_save)
        print(f"üì∏ ƒê√£ l∆∞u ·∫£nh c·ª•c b·ªô t·∫°i: {image_path_tosave}")
    except Exception as e_imwrite:
        print(f"‚ùå L·ªói khi l∆∞u ·∫£nh c·ª•c b·ªô: {e_imwrite}")
        return
    try:
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO transactions (plate, token, timestamp, image_path, synced)
                VALUES (?, ?, ?, ?, ?)
            ''', (plate, str(token_id), timestamp_to_save, image_path_tosave, 0))
            conn.commit()
        print("üíæ D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o h√†ng ƒë·ª£i c·ª•c b·ªô.")
    except sqlite3.Error as e_db:
        print(f"‚ùå L·ªói SQLite khi l∆∞u v√†o CSDL c·ª•c b·ªô: {e_db}")
    except Exception as e_save:
        print(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh khi l∆∞u v√†o CSDL c·ª•c b·ªô: {e_save}")


def sync_offline_data_to_server():
    """H√†m ch·∫°y n·ªÅn ƒë·ªÉ ƒë·ªìng b·ªô d·ªØ li·ªáu ƒë√£ l∆∞u c·ª•c b·ªô."""
    while True:
        print("\nüîÑ [Sync Thread] B·∫Øt ƒë·∫ßu ki·ªÉm tra d·ªØ li·ªáu c·∫ßn ƒë·ªìng b·ªô...")
        conn = None
        records_processed_in_batch = 0
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM transactions WHERE synced = 0 LIMIT 5")
            records_to_sync = cursor.fetchall()

            if not records_to_sync:
                print("üëç [Sync Thread] Kh√¥ng c√≥ d·ªØ li·ªáu m·ªõi. H√†ng ƒë·ª£i s·∫°ch.")
            else:
                print(f"‚è≥ [Sync Thread] T√¨m th·∫•y {len(records_to_sync)} b·∫£n ghi c·∫ßn ƒë·ªìng b·ªô.")
                for record in records_to_sync:
                    records_processed_in_batch += 1
                    record_id, plate, token, timestamp, image_path, _ = record
                    print(f"  -> ƒêang th·ª≠ ƒë·ªìng b·ªô b·∫£n ghi ID: {record_id}, Bi·ªÉn s·ªë: {plate}")
                    
                    if not os.path.exists(image_path):
                        print(f"  L·ªói: Kh√¥ng t√¨m th·∫•y file ·∫£nh {image_path} cho ID {record_id}. ƒê√°nh d·∫•u l√† ƒë√£ ƒë·ªìng b·ªô ƒë·ªÉ b·ªè qua.")
                        cursor.execute("UPDATE transactions SET synced = 1 WHERE id = ?", (record_id,))
                        conn.commit()
                        continue

                    try:
                        with open(image_path, 'rb') as img_file:
                            image_bytes = img_file.read()
                        
                        if send_data_to_server(plate, token, timestamp, image_bytes):
                            print(f"  ‚úÖ ƒê·ªìng b·ªô th√†nh c√¥ng ID: {record_id} t·ª´ h√†ng ƒë·ª£i.")
                            cursor.execute("UPDATE transactions SET synced = 1 WHERE id = ?", (record_id,))
                            conn.commit()
                            # T√πy ch·ªçn x√≥a ·∫£nh sau khi ƒë·ªìng b·ªô th√†nh c√¥ng t·ª´ h√†ng ƒë·ª£i
                            # try:
                            #     os.remove(image_path)
                            #     print(f"    ƒê√£ x√≥a file ·∫£nh offline: {image_path}")
                            # except OSError as e_remove:
                            #     print(f"    L·ªói khi x√≥a file ·∫£nh offline {image_path}: {e_remove}")
                        else:
                            print(f"  ‚ùå G·ª≠i d·ªØ li·ªáu t·ª´ h√†ng ƒë·ª£i th·∫•t b·∫°i cho ID: {record_id}. S·∫Ω th·ª≠ l·∫°i sau.")
                            # N·∫øu send_data_to_server tr·∫£ v·ªÅ False do l·ªói m·∫°ng/server,
                            # n√≥ s·∫Ω ƒë∆∞·ª£c th·ª≠ l·∫°i trong l·∫ßn l·∫∑p ti·∫øp theo c·ªßa sync thread.
                            # N·∫øu l·ªói l√† do d·ªØ li·ªáu (vd: ·∫£nh h·ªèng m√† send_data_to_server kh√¥ng b·∫Øt ƒë∆∞·ª£c),
                            # c·∫ßn c∆° ch·∫ø kh√°c ƒë·ªÉ ƒë√°nh d·∫•u l√† "kh√¥ng th·ªÉ g·ª≠i".
                    except IOError as e_io:
                        print(f"  L·ªói IO khi ƒë·ªçc file ·∫£nh {image_path} cho ID {record_id}: {e_io}. ƒê√°nh d·∫•u l·ªói.")
                        # C√¢n nh·∫Øc ƒë√°nh d·∫•u b·∫£n ghi n√†y l√† c√≥ l·ªói vƒ©nh vi·ªÖn n·∫øu kh√¥ng ƒë·ªçc ƒë∆∞·ª£c ·∫£nh
                        # cursor.execute("UPDATE transactions SET synced = 2 WHERE id = ?", (record_id,)) # synced = 2 l√† l·ªói
                        # conn.commit()
                    except Exception as e_inner_sync:
                         print(f"  L·ªói kh√¥ng x√°c ƒë·ªãnh trong qu√° tr√¨nh x·ª≠ l√Ω b·∫£n ghi ID {record_id}: {e_inner_sync}")

        except sqlite3.Error as e_sql:
            print(f"üö® [Sync Thread] L·ªói SQLite: {e_sql}")
        except Exception as e_sync_outer:
            print(f"üö® [Sync Thread] G·∫∑p l·ªói kh√¥ng x√°c ƒë·ªãnh b√™n ngo√†i v√≤ng l·∫∑p b·∫£n ghi: {e_sync_outer}")
        finally:
            if conn:
                conn.close()
        
        sleep_duration = 10 if records_processed_in_batch > 0 else 30 # Ch·ªù √≠t h∆°n n·∫øu c√≥ ho·∫°t ƒë·ªông
        print(f"üîÑ [Sync Thread] K·∫øt th√∫c l∆∞·ª£t ki·ªÉm tra. Ch·ªù {sleep_duration} gi√¢y.")
        time.sleep(sleep_duration)

# --- KH·ªûI T·∫†O H·ªÜ TH·ªêNG ---
print("üöÄ B·∫Øt ƒë·∫ßu kh·ªüi t·∫°o h·ªá th·ªëng...")
init_db()
try:
    yolo_LP_detect = torch.hub.load(YOLOV5_REPO_PATH, 'custom', path=LP_DETECTOR_MODEL_PATH, source='local', _verbose=False)
    yolo_license_plate = torch.hub.load(YOLOV5_REPO_PATH, 'custom', path=LP_OCR_MODEL_PATH, source='local', _verbose=False)
    yolo_license_plate.conf = 0.60
    
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        raise IOError("Kh√¥ng th·ªÉ m·ªü webcam")
    reader = SimpleMFRC522()
    print("‚úÖ Kh·ªüi t·∫°o model, camera v√† RFID th√†nh c√¥ng!")
except Exception as e:
    print(f"‚ùå L·ªói kh·ªüi t·∫°o h·ªá th·ªëng: {e}")
    exit()

sync_thread = threading.Thread(target=sync_offline_data_to_server, daemon=True) # ƒê·ªïi t√™n h√†m target
sync_thread.start()
print("üöÄ ƒê√£ kh·ªüi ƒë·ªông ti·∫øn tr√¨nh ƒë·ªìng b·ªô n·ªÅn.")

# --- V√íNG L·∫∂P CH√çNH ---
try:
    while True:
        print("\n-----------------------------------------")
        print("üí° Vui l√≤ng ƒë∆∞a th·∫ª v√†o ƒë·∫ßu ƒë·ªçc...")
        rfid_id, rfid_text = (None, None)
        try:
            # C√¢n nh·∫Øc d√πng reader.read_id_no_block() n·∫øu th∆∞ vi·ªán h·ªó tr·ª£ v√† ph√π h·ª£p v·ªõi lu·ªìng
            rfid_id, rfid_text = reader.read() 
            print(f"‚úÖ ƒê√£ nh·∫≠n th·∫ª! ID: {rfid_id}, Text: {rfid_text}")
        except Exception as e_rfid:
            print(f"L·ªói ƒë·ªçc th·∫ª RFID: {e_rfid}. ƒêang th·ª≠ l·∫°i...")
            time.sleep(0.5) 
            continue

        print("üì∏ B·∫Øt ƒë·∫ßu ch·ª•p ·∫£nh v√† nh·∫≠n d·∫°ng bi·ªÉn s·ªë...")
        for _ in range(5): cap.read() # X·∫£ buffer
        ret, frame = cap.read()
        if not ret or frame is None:
            print("‚ùå Kh√¥ng th·ªÉ l·∫•y khung h√¨nh t·ª´ camera.")
            continue
        
        process_frame = frame.copy()
        plate_detection_results = yolo_LP_detect(process_frame, size=640)
        detected_plates_coords = plate_detection_results.pandas().xyxy[0].values.tolist()
        
        found_license_plate_text = None
        
        if not detected_plates_coords:
            # Th·ª≠ ƒë·ªçc tr√™n to√†n khung h√¨nh n·∫øu kh√¥ng c√≥ bounding box
            lp_candidate = helper.read_plate(yolo_license_plate, process_frame)
            if lp_candidate != "unknown" and lp_candidate != "":
                found_license_plate_text = lp_candidate
        else:
            for plate_coords in detected_plates_coords:
                x1, y1, x2, y2 = map(int, plate_coords[:4])
                cropped_plate_img = process_frame[y1:y2, x1:x2]
                
                if cropped_plate_img.size == 0: continue # B·ªè qua n·∫øu crop r·ªóng

                lp_text_from_crop = "unknown"
                # C√¢n nh·∫Øc gi·∫£m v√≤ng l·∫∑p deskew n·∫øu kh√¥ng c·∫ßn thi·∫øt ho·∫∑c t·ªën th·ªùi gian
                for cc_angle_index in range(1): # Gi·∫£m th·ª≠ nghi·ªám xoay ƒë·ªÉ nhanh h∆°n
                    for ct_tilt_index in range(1):
                        # deskewed_img = utils_rotate.deskew(cropped_plate_img, cc_angle_index, ct_tilt_index)
                        deskewed_img = cropped_plate_img # B·ªè qua deskew n·∫øu d√πng mock
                        
                        lp_candidate = helper.read_plate(yolo_license_plate, deskewed_img)
                        if lp_candidate != "unknown" and lp_candidate != "":
                            lp_text_from_crop = lp_candidate
                            break 
                    if lp_text_from_crop != "unknown":
                        break 
                
                if lp_text_from_crop != "unknown":
                    found_license_plate_text = lp_text_from_crop
                    break # D·ª´ng l·∫°i khi t√¨m th·∫•y bi·ªÉn s·ªë ƒë·∫ßu ti√™n

        if found_license_plate_text:
            print(f"üéâ Ph√°t hi·ªán th√†nh c√¥ng bi·ªÉn s·ªë: {found_license_plate_text}")
            
            current_timestamp_str = get_vietnam_time_str()
            
            # Encode ·∫£nh th√†nh bytes ƒë·ªÉ g·ª≠i
            is_encode_success, image_buffer_array = cv2.imencode(".jpg", frame)
            if not is_encode_success:
                print("‚ùå L·ªói khi encode ·∫£nh!")
                # N·∫øu l·ªói encode, ch·ªâ l∆∞u text v√†o DB, kh√¥ng c√≥ ·∫£nh
                save_record_to_local_db(found_license_plate_text, rfid_id, frame, current_timestamp_str, "L·ªói encode ·∫£nh khi g·ª≠i tr·ª±c ti·∫øp")
            else:
                image_bytes_to_send = image_buffer_array.tobytes()
                
                # ∆Øu ti√™n g·ª≠i tr·ª±c ti·∫øp l√™n server
                if send_data_to_server(found_license_plate_text, rfid_id, current_timestamp_str, image_bytes_to_send):
                    print("‚ú® Ho√†n t·∫•t x·ª≠ l√Ω (g·ª≠i tr·ª±c ti·∫øp th√†nh c√¥ng).")
                else:
                    # N·∫øu g·ª≠i tr·ª±c ti·∫øp th·∫•t b·∫°i, l∆∞u v√†o CSDL c·ª•c b·ªô
                    save_record_to_local_db(found_license_plate_text, rfid_id, frame, current_timestamp_str, "G·ª≠i tr·ª±c ti·∫øp th·∫•t b·∫°i")
        else:
            print("üòî Kh√¥ng nh·∫≠n d·∫°ng ƒë∆∞·ª£c bi·ªÉn s·ªë n√†o.")
        
        time.sleep(0.1) # Ch·ªù m·ªôt ch√∫t gi·ªØa c√°c l·∫ßn qu√©t

except KeyboardInterrupt:
    print("\nüõë Ch∆∞∆°ng tr√¨nh ƒë√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng.")
except Exception as e_main_loop:
    print(f"üö® L·ªói nghi√™m tr·ªçng trong v√≤ng l·∫∑p ch√≠nh: {e_main_loop}")
finally:
    print("üßπ D·ªçn d·∫πp t√†i nguy√™n...")
    if 'cap' in locals() and cap.isOpened():
        cap.release()
    if 'GPIO' in locals() : # Ch·ªâ cleanup n·∫øu GPIO ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng
        GPIO.cleanup()
    print("üëã K·∫øt th√∫c ch∆∞∆°ng tr√¨nh!")