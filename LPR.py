import cv2
import torch
import os
import time
from datetime import datetime, timezone, timedelta
import RPi.GPIO as GPIO
from mfrc522 import SimpleMFRC522
import requests
import sqlite3
import function.utils_rotate as utils_rotate
import function.helper as helper
import threading

API_ENDPOINT = "http://192.168.137.206:3000/parking/add"

DB_FILE = "parking_data.db"

def init_db():
    """Kh·ªüi t·∫°o c∆° s·ªü d·ªØ li·ªáu v√† b·∫£ng n·∫øu ch∆∞a t·ªìn t·∫°i"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS transactions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            plate TEXT NOT NULL,
            token TEXT NOT NULL,
            timestamp TEXT NOT NULL, 
            image_path TEXT NOT NULL,
            synced INTEGER NOT NULL DEFAULT 0
        )
    ''')
    conn.commit()
    conn.close()
    print(f"‚úÖ ƒê√£ kh·ªüi t·∫°o ho·∫∑c k·∫øt n·ªëi t·ªõi CSDL: {DB_FILE}")

def sync_data_to_server():
    """H√†m ch·∫°y n·ªÅn ƒë·ªÉ ƒë·ªìng b·ªô d·ªØ li·ªáu"""
    while True:
        print("üîÑ [Sync Thread] B·∫Øt ƒë·∫ßu ki·ªÉm tra d·ªØ li·ªáu c·∫ßn ƒë·ªìng b·ªô...")
        conn = None
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            cursor.execute("SELECT * FROM transactions WHERE synced = 0 LIMIT 5")
            records_to_sync = cursor.fetchall()
            
            if not records_to_sync:
                print("üëç [Sync Thread] Kh√¥ng c√≥ d·ªØ li·ªáu m·ªõi. H√†ng ƒë·ª£i s·∫°ch.")
            else:
                print(f"‚è≥ [Sync Thread] T√¨m th·∫•y {len(records_to_sync)} b·∫£n ghi c·∫ßn ƒë·ªìng b·ªô.")
                for record in records_to_sync:
                    # C·∫≠p nh·∫≠t th·ª© t·ª± gi·∫£i n√©n tuple cho ph√π h·ª£p
                    record_id, plate, token, timestamp, image_path, _ = record # B·ªè in_out
                    
                    print(f"  -> ƒêang th·ª≠ ƒë·ªìng b·ªô b·∫£n ghi ID: {record_id}, Bi·ªÉn s·ªë: {plate}")
                    
                    # Chu·∫©n b·ªã payload (kh√¥ng c√≥ in_or_out)
                    payload = {
                        'plate': plate,
                        'token': token,
                        'time': timestamp
                    }
                    
                    if not os.path.exists(image_path):
                        print(f"  L·ªói: Kh√¥ng t√¨m th·∫•y file ·∫£nh {image_path}. ƒê√°nh d·∫•u l√† ƒë√£ ƒë·ªìng b·ªô ƒë·ªÉ b·ªè qua.")
                        cursor.execute("UPDATE transactions SET synced = 1 WHERE id = ?", (record_id,))
                        conn.commit()
                        continue

                    with open(image_path, 'rb') as img_file:
                        files_payload = {
                            'image': (os.path.basename(image_path), img_file, 'image/jpeg')
                        }
                        
                        try:
                            response = requests.post(API_ENDPOINT, data=payload, files=files_payload, timeout=15)
                            
                            if response.status_code == 200:
                                print(f"  ‚úÖ ƒê·ªìng b·ªô th√†nh c√¥ng ID: {record_id}")
                                cursor.execute("UPDATE transactions SET synced = 1 WHERE id = ?", (record_id,))
                                conn.commit()
                                # (T√πy ch·ªçn) X√≥a file ·∫£nh ƒë√£ ƒë·ªìng b·ªô
                                # try:
                                #    os.remove(image_path)
                                #    print(f"    ƒê√£ x√≥a file ·∫£nh: {image_path}")
                                # except OSError as e_remove:
                                #    print(f"    L·ªói khi x√≥a file ·∫£nh {image_path}: {e_remove}")
                            else:
                                print(f"  ‚ùå L·ªói server khi ƒë·ªìng b·ªô ID: {record_id}. M√£: {response.status_code}. S·∫Ω th·ª≠ l·∫°i sau.")
                        
                        except requests.exceptions.RequestException as e_req:
                            print(f"  ‚ùå M·∫•t k·∫øt n·ªëi m·∫°ng ho·∫∑c l·ªói y√™u c·∫ßu. Kh√¥ng th·ªÉ ƒë·ªìng b·ªô ID: {record_id}. L·ªói: {e_req}. S·∫Ω th·ª≠ l·∫°i sau.")
                            break 
        
        except Exception as e_sync:
            print(f"üö® [Sync Thread] G·∫∑p l·ªói nghi√™m tr·ªçng: {e_sync}")
        
        finally:
            if conn:
                conn.close()

        time.sleep(30)

def save_record_to_local_db(plate, token_id, image_frame_to_save, reason=""):
    """L∆∞u b·∫£n ghi v√†o CSDL c·ª•c b·ªô khi g·ª≠i tr·ª±c ti·∫øp th·∫•t b·∫°i."""
    print(f"üíΩ ƒêang l∆∞u v√†o CSDL c·ª•c b·ªô. L√Ω do: {reason}")
    
    # 1. L∆∞u file ·∫£nh v√†o m·ªôt th∆∞ m·ª•c c·ª•c b·ªô
    safe_lp_for_filename = "".join(c if c.isalnum() else "_" for c in plate).rstrip("_")
    timestamp_filename_str = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
    image_filename = f"{timestamp_filename_str}_{safe_lp_for_filename}.jpg"
    image_path_tosave = os.path.join(IMAGE_DIR, image_filename) # IMAGE_DIR ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a to√†n c·ª•c
    
    try:
        cv2.imwrite(image_path_tosave, image_frame_to_save)
        print(f"üì∏ ƒê√£ l∆∞u ·∫£nh c·ª•c b·ªô t·∫°i: {image_path_tosave}")
    except Exception as e_imwrite:
        print(f"‚ùå L·ªói khi l∆∞u ·∫£nh c·ª•c b·ªô: {e_imwrite}")
        return # Kh√¥ng l∆∞u v√†o DB n·∫øu kh√¥ng l∆∞u ƒë∆∞·ª£c ·∫£nh

    # 2. Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ l∆∞u v√†o CSDL
    vietnam_tz = timezone(timedelta(hours=7)) # ƒê·∫£m b·∫£o timezone, timedelta ƒë√£ import
    current_time = datetime.now(vietnam_tz)
    formatted_time_str = current_time.strftime("%Y-%m-%d %H:%M:%S")

    # 3. Ch√®n d·ªØ li·ªáu v√†o CSDL SQLite
    try:
        conn = sqlite3.connect(DB_FILE) # DB_FILE ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a to√†n c·ª•c
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO transactions (plate, token, timestamp, image_path, synced)
            VALUES (?, ?, ?, ?, ?)
        ''', (plate, str(token_id), formatted_time_str, image_path_tosave, 0))
        conn.commit()
        conn.close()
        print("üíæ D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o h√†ng ƒë·ª£i c·ª•c b·ªô.")
    except Exception as e_db:
        print(f"‚ùå L·ªói khi l∆∞u v√†o CSDL c·ª•c b·ªô: {e_db}")

def sanitize_filename(name):
    return "".join(c if c.isalnum() else "_" for c in name).rstrip("_")

def get_timestamp_str():
    now = datetime.now()
    return now.strftime("%d_%m_%Y_%Hh%M")

# --- KH·ªûI T·∫†O C√ÅC TH√ÄNH PH·∫¶N ---
print("üöÄ B·∫Øt ƒë·∫ßu kh·ªüi t·∫°o h·ªá th·ªëng...")
output_dir = "picture"
os.makedirs(output_dir, exist_ok=True)
print(f"‚úÖ Th∆∞ m·ª•c l∆∞u ·∫£nh: '{output_dir}'")

init_db()

sync_thread = threading.Thread(target=sync_data_to_server, daemon=True)
sync_thread.start()
print("üöÄ ƒê√£ kh·ªüi ƒë·ªông ti·∫øn tr√¨nh ƒë·ªìng b·ªô n·ªÅn.")

try:
    yolov5_repo = '/home/minhtest/yolov5'
    yolo_LP_detect = torch.hub.load(yolov5_repo, 'custom', path='model/LP_detector_nano_61.pt', source='local')
    yolo_license_plate = torch.hub.load(yolov5_repo, 'custom', path='model/LP_ocr_nano_62.pt', source='local')
    yolo_license_plate.conf = 0.60
    print("‚úÖ T·∫£i model YOLO th√†nh c√¥ng!")
except Exception as e:
    print(f"‚ùå L·ªói khi t·∫£i model YOLO: {e}")
    exit()
cap = cv2.VideoCapture(0)
if not cap.isOpened():
    print("‚ùå L·ªói: Kh√¥ng th·ªÉ m·ªü webcam.")
    exit()
else:
    print("‚úÖ M·ªü webcam th√†nh c√¥ng!")
reader = SimpleMFRC522()
print("‚úÖ Kh·ªüi t·∫°o ƒë·∫ßu ƒë·ªçc RFID th√†nh c√¥ng!")

# --- V√íNG L·∫∂P CH√çNH ---
try:
    while True:
        print("\n-----------------------------------------")
        print("üí° Vui l√≤ng ƒë∆∞a th·∫ª v√†o ƒë·∫ßu ƒë·ªçc...")

        id, text = reader.read()
        print(f"‚úÖ ƒê√£ nh·∫≠n th·∫ª! ID: {id}, Text: {text}")
        print("üì∏ B·∫Øt ƒë·∫ßu ch·ª•p ·∫£nh v√† nh·∫≠n d·∫°ng bi·ªÉn s·ªë...")

        for _ in range(5):
            cap.read()

        ret, frame = cap.read()
        if not ret:
            print("‚ùå Kh√¥ng th·ªÉ l·∫•y khung h√¨nh t·ª´ camera.")
            continue

        # (Logic nh·∫≠n d·∫°ng bi·ªÉn s·ªë gi·ªØ nguy√™n...)
        process_frame = frame.copy()
        results = yolo_LP_detect(process_frame, size=640)
        list_plates = results.pandas().xyxy[0].values.tolist()

        found_plate_text = None
        if not list_plates:
            lp = helper.read_plate(yolo_license_plate, process_frame)
            if lp != "unknown" and lp != "":
                found_plate_text = lp
        else:
            for i, plate in enumerate(list_plates):
                x1, y1, x2, y2 = map(int, plate[:4])
                crop_img = process_frame[y1:y2, x1:x2]
                lp_text = "unknown"
                for cc in range(2):
                    for ct in range(2):
                        rotated_img = utils_rotate.deskew(crop_img, cc, ct)
                        lp = helper.read_plate(yolo_license_plate, rotated_img)
                        if lp != "unknown" and lp != "":
                            lp_text = lp
                            break
                    if lp_text != "unknown":
                        break
                if lp_text != "unknown":
                    found_plate_text = lp_text
                    break

        if found_plate_text:
            print(f"üéâ Ph√°t hi·ªán th√†nh c√¥ng bi·ªÉn s·ªë: {found_plate_text}")

            # --- L∆ØU D·ªÆ LI·ªÜU C·ª§C B·ªò ---
            
            # 1. L∆∞u file ·∫£nh v√†o m·ªôt th∆∞ m·ª•c c·ª•c b·ªô
            # S·ª≠ d·ª•ng found_plate_text ƒë√£ ƒë∆∞·ª£c sanitize (n·∫øu c·∫ßn)
            safe_lp_for_filename = "".join(c if c.isalnum() else "_" for c in found_plate_text).rstrip("_")
            timestamp_filename = datetime.now().strftime("%Y%m%d_%H%M%S")
            image_filename = f"{timestamp_filename}_{safe_lp_for_filename}.jpg"
            image_dir = "offline_images" # Th∆∞ m·ª•c l∆∞u ·∫£nh
            os.makedirs(image_dir, exist_ok=True) # ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i
            image_path = os.path.join(image_dir, image_filename)
            
            cv2.imwrite(image_path, frame) # L∆∞u ·∫£nh g·ªëc
            print(f"üì∏ ƒê√£ l∆∞u ·∫£nh c·ª•c b·ªô t·∫°i: {image_path}")

            # 2. Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ l∆∞u v√†o CSDL
            vietnam_tz = timezone(timedelta(hours=7))
            current_time = datetime.now(vietnam_tz)
            formatted_time_str = current_time.strftime("%Y-%m-%d %H:%M:%S")

            # 3. Ch√®n d·ªØ li·ªáu v√†o CSDL SQLite (kh√¥ng c√≥ in_or_out)
            try:
                conn = sqlite3.connect(DB_FILE)
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO transactions (plate, token, timestamp, image_path, synced)
                    VALUES (?, ?, ?, ?, ?)
                ''', (found_plate_text, str(id), formatted_time_str, image_path, 0)) # Lo·∫°i b·ªè gi√° tr·ªã '1'
                conn.commit()
                conn.close()
                print("üíæ D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o h√†ng ƒë·ª£i c·ª•c b·ªô.")
            except Exception as e:
                print(f"‚ùå L·ªói khi l∆∞u v√†o CSDL c·ª•c b·ªô: {e}")

        else:
            print("üòî Kh√¥ng nh·∫≠n d·∫°ng ƒë∆∞·ª£c bi·ªÉn s·ªë n√†o.")

except KeyboardInterrupt:
    print("\nüõë Ch∆∞∆°ng tr√¨nh ƒë√£ d·ª´ng b·ªüi ng∆∞·ªùi d√πng.")

finally:
    print("üßπ D·ªçn d·∫πp t√†i nguy√™n...")
    cap.release()
    GPIO.cleanup()
    print("üëã K·∫øt th√∫c ch∆∞∆°ng tr√¨nh!")
